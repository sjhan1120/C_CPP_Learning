[포인터와 배열 서론]
    주소:   변수, 상수 선언과 데이터 입력 시 데이터 관리를 위하여 메모리에 부여되는 일련의 번호.
    &:      주소연산자. 해당 메모리의 주소를 알 수 있음.
        -& 연산자 팁
            1. 주소연산자:          변수 데이터가 저장된 메모리 주소(&변수명)
            2. 참조자(reference):   실제 변수이름 대신에 또 다른 이름 선언(별명), 같은 위치의 메모리 위치를 참조.
                int a  = 10;
                int &b = a;     //a와 b의 값은 동일한 10
            3. bit연산(AND):        &
            4. 논리연산(AND):       &&
    
    포인터: 변수에 '데이터가 저장된 주소'를 저장하여 관리하고 이 주소를 활용하는 방법
            변수명 앞 혹은 자료형 뒤에 포인터 기호 * 를 붙여준다.
    배열:   같은 이름을 갖는 여러 개의 변수를 하나의 통합된 묶음으로 관리할 필요가 있을 때 편리하게 사용하는 방법

[포인터(pointer)]
    포인터에 저장되어 있는 값은 실제의 데이터 값이 아니라 실제 데이터가 저장되어 있는 메모리의 주소를 가리킴.
    실제 데이터가 저장되어 있는 번지를 기억하는 데 사용하는 변수를 포인터 변수라고 함.

    장점:   이해만 잘하면 프로그램을 작성할 때 고급 프로그램화 할 수 있음. 방대한 양의 데이터를 다룰 때 유용하게 응용됨.
    주의:   부주의한 포인터의 이용은 혼란을 가져오기 때문에 동작 원리를 잘 이해하고 절제하여 사용해야 함.

    -포인터 팁
        1. pointer 선언 기본형식
            -자료형 *포인터명;
            -포인터명 = address;
                또는
            -자료형 *포인터명 = address;
                또는
            -자료형 *포인터명 = new 자료형  //C++추가 기능.
        2. 포인터 선언 변수 해석
            -주소: 포인터 변수명
            -주소가 가르치는 메모리의 역참조 데이터: *포인터명

        new연산자를 이용하면 컴퓨터가 자동으로 주소를 할당해 줌. 포인터 변수에 *동적으로 할당하고 싶은 메모리 크기를 지정함.
            int *pData=new int;
            *pData= 정수 데이터;    //역참조
                또는
            int *pData=new int(정수 데이터);    //데이터 초기화

            *동적: ch3_1_정적 동적할당.txt 참고 바람...
    
    3_1_pointer 참고바람...

    주의2:  포인터로 선언된 변수는 반드시 프로그램 내에서 반드시 초기화하여야 함.
            초기화 하지 않을 경우 주소값을 가리키는 포인터 변수는 쓰레기 값이 들어가서 이상한 곳을 가리키게 됨.
            만약 그곳이 컴퓨터 메모리 상 중요한 곳이라면 위험해짐.
            따라서 특정 주소로 초기화 하거나 아니면 0(=NULL)으로 초기화를 하는 것이 안전함.
            0(=NULL)은 0이라는 주소가 아니라 아무것도 가리키지 않는다는 의미임.

[배열(array)]
    같은 이름을 같는 여러개의 변수를 하나의 통합된 묶음으로 관리할 때 사용하는 편리한 방법.
    배열이 선언되면 배열에서 선언된 개 수만큼의 기억장소가 주 메모리에서 자동으로 할당됨.
    구성:   배열원소(Element):  개별적인 자료를 기억할 수 있는 장소.
            번호(Index):        배열원소들을 구별하는 일련번호. 반드시 0부터 시작하고 선언된 배열의 개 수보다 하나 작은 수까지임.    
    배열도 다른 자료형 선언과 마찬가지로 프로그램에서 사용되기 전에 미리 선언되어있어야 컴퓨터가 해당하는 기억장소를 미리 할당하여 확봐함.

    -1차원 배열(One Dimensional Array)
        같은 자료형 데이터를 1차원으로 선언한 것.
        선언:   자료형 변수명[개수];
        초기화: 1.  int nValue[4]=  {100,200,300,1000};
                2.  int nValue[]=   {100,200,300,1000};     //자동으로 4개의 메모리 공간 지정
                3.  int nValue[4];
                    nValue[0]=100; nValue[1]=200;
                    nValue[2]=300; nValue[3]=1000;
        
        3_2_oneDimArr.cpp 참고바람...

        알고리즘: 체계적으로 목표를 달성하도록 하는 방법.
        -오름차순 정렬하기 위한 알고리즘
            -첫 번째 값을 나머지 모든 값과 비교하여 현재 값이 가장 크면 현재값의 위치를 바꾼다.
            -두 번째 값을 세 번째 이하 값과 비교하여 상기 과정을 반복한다.
            -반복해서 나머지를 실행한다.

            3_3_ascendingOrder.cpp 참고바람...
    
    -2차원 배열(Two Dimensional Array)
        자료형 배열명 [크기1] [크기2]
            -크기1은 행의 수, 크기2는 열의 수
            -기억장소의 총 개수는 크기1과 크기2를 곱한 값 즉 행의 수와 열의 수를 곱하면 총 요소의 개수
    
[범위 기반(rage-based) for()문과 배열]
    배열(list) 요소값을 차례로 처리하는 기능.
    
    -범위기반 for()문 팁
        기능: 배열 데이터가 차례로 지정한 변수에 복사
        형식
            1.  순차 복사형: 배열 요소 데이터가 차례대로 복사
                for(자료형 변수명 : 배열명)
                {
                    변수명 이용;
                }
                예)
                int nData[4]={10,20,30,40}
                for(int k : nData) cout << k;   //출력 10, 20, 30, 40

                단점:   -index정보가 존재하지 않아 index로 구분할 수 있는 여러가지 조절이 힘듦. (for문에서의 i가 없음)
                        -배열의 요소들이 변수에 복사가 되기 때문에 배열의 요소를 변경할 수 없음.
                        -복사를 했기 때문에 복사 비용이 발생함.

            2.  *순차 참조형: 배열 요소 데이터가 차례대로 *참조자로 이용
                for(자료형& 변수명 : 배열명)
                {
                    변수명 이용;
                }
                예)
                int nData[4]={10,20,30,40}
                for(int& k : nData) cout << k;   //출력 10, 20, 30, 40

                장점:   -참조자를 사용하므로 복사비용이 들지 않아 비용이 감소함.
                        -배열의 원래 요소를 변경 가능.
                *참조자:    할당된 하나의 메모리 공간에 다른 이름을 붙이는 것. 대상 변수와 같은 메모리 위치를 참조하게됨.
                            변수에 붙는 별명이라고 생각하면 됨.
                call-by-value:      값을 인자로 전달하는 함수호출 방식. 함수 외부에 선언된 변수에 대한 접근 불가.
                call-by-reference:  주소 값을 인자로 전달하는 함수의 호출방식. 함수 외부에 선언된 변수의 변형이 가능함.
        
        3_4_arrfor.cpp참고바람.
    
[배열과 포인터]
    -배열과 pointer 팁
        1.  배열로 저장된 방대한 양의 데이터를 새로운 변수로 복사할 때 데이터가 저장된 주소의 시작 주소만을 복사하여
            메모리를 효율적으로 관리하기 위해 사용
        2.  배열을 pointer로 표현하면 1개 차수가 감소함
        
        -1차원 배열과 pointer
            자료형 배열이름[크기];
            -배열 이름 = &배열이름[0]       //배열원소 0번째 데이터 저장위치의 주소
            -*(배열이름+N) = 배열이름[N]    //배열요소 N번째 데이터
            -*배열이름 = 배열이름[0]        //배열요소 0번째 데이터

        -2차원 배열과 pointer
            자료형 배열이름[크기1][크기2]
            //첫 번째 원소 데이터 저장위치의 주소
            -배열이름 = &배열이름[0][0] = 배열이름[0]
            //특정위치에 저장된 데이터
            -*(배열이름[N1] + N2) = 배열이름[N1][N2]

    3_5_oneDimPointer.cpp 참고바람...
    3_6_twoDimpointer.cpp 참고바람...

    1차원 배열에 포인터를 붙이면 2차원이 됨.

    3_7_mixArrPointer.cpp 참고바람...

[동적 메모리 할당]
    정적메모리 할당:            배열을 사용할 때 크기를 자료형으로 선언할 때 초기에 정하고 사용하는 방식.
    정적메모리 할당의 단점:     외부에서 데이터를 입력받을 때 초기부터 데이터의 개수를 알 수 없어 배열 선언이 곤란함.
    동적 메모리 할당과 해제:    필요한 메모리를 확보하고 사용이 끝나면 메모리 사용을 해제하는 기능.
        C언어: malloc() 함수, free() 함수 (Heap영역에 할당됨)

    가상 메모리 구조
        -프로그램 code 영역
        -Data 영역:         전역변수와 정적변수, 전역 class의 인스턴스가 저장됨.
        -heap & Stack 영역: 동적메모리 할당과 백라운드에서 작동하는 쓰래드가 돌아감.
    
    malloc, free함수의 단점
        1. 문법이 복잡함
        2. class에서 객체를 동적으로 생성할 때 생성자를 호출하지 못함.
    
    대안: C++에서 새로운 메모리 할당 연산자를 제공함. new-delete연산자.

    -동적 메모리 할당과 해제 팁
        1. 할당
            -일반 변수
            자료형 *포인터 변수명 = new 자료형
            int *pA= new int;
            -배열
            자료형 *포인터 변수명 = new 자료형[크기]
            예) int *pA=new int[10];
        
        2.해제
            1. 지역변수로 선언한 경우 } 를 만나면 자동해제
            2. 임의의 위치에서 해제를 원하는 경우
                일반변수:   delete 변수명;      예) delete pA;
                배열:       delete[] 변수명;    예) delete[] pA;
                구조체, class는 해당 단원에서 기술
    
    3_8_dynamicAlloc.cpp 참고바람...
