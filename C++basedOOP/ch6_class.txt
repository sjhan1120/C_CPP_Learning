[class 서론]
    class:  서로다른 형태의 변수들을 하나의 묶음으로 사용할 수 있는 구조체에
            함수를 추가하고 이들을 묶어서 하용범위를 지정할 수 있도록 기능을 확대하여 C++에 도입된 개념

    일종의 설계도인 구조체를 미리 선언하고 선언된 구조체 전체를 하나의 독립적인 객체들로 생성하여 사용하였음.
    마찬가지로 class를 선언하고 이를 근거로 각각의 독립적인 객체로 사용하기 위하여 class를 대상으로 실제 사용하는 객체로 선언하는 것을
    '객체(object)를 생성한다'라고 함. 이때 생성된 객체는 메모리에서 공간을 할당 받는데 이를 인스턴스(instance)라고함.

[class 설계]
    객체의 의미:    눈, 귀, 코, 혀, 몸 등의 감각기관으로 이루어진 사람은  각각 그 구성이 동일하지만 이를 바탕으로 태어난 사람들은
                    각각마다 독자적으로 다른 모습과 행동을 하고 있다. 이같이 독립적인 존재 자체를 객체라고 부른다.
    
    class의 의미:   아파트를 지을 때는 반드시 설계도를 먼저 작성 후 이를 바탕으로 동일한 구조의 아파트를 건설한다.
                    아파트의 구조는 같지만 그 안에 거주하는 구성원은 집집마다 다르다.
                    여기서 설계도를 class, 각각의 세대를 객체, 각 세대의 구성원을 멤버변수 혹은 멤버함수라고 부른다.
    
    객체지향프로그래밍의 특징
        1. 추상화(abstraction)      객체 지향적 관점에서 class를 정의하는 것을 추상화라고 표현하고
                                    공통의 속성이나 기능을 묶어 이름을 붙이는 것으로 설계도를 의미함.
        2. 캡슐화(encapsulation)    멤버변수와 멤버함수를 하나의 단위로 묶어 결합하는 것.
                                    객체가 요구되는 소임을 수행하기 위하여 하나의 목적으로 묶어서 처리하기 때문에
                                    class가 프로그램의 부품처럼 사용할 수 있도록 해주는 것임.
        3. 정보은닉(data hiding)    캡슐화한 묶음은 접근을 허용하지 않는 한 외부에서 접근할 수 없으며
                                    접근은 오직 함수의 매개변수를 통해서만 접근할 수 있도록 하는 것을 말함.
        4. 상속성(inheritance)      상위 class에서 선언한 멤버변수와 멤버함수의 기능을 하위 class에서 물려받는 것을 말함.
                                    상위 class를 부모 class, 하위 class를 자식 class라고도 부름.
                                    절차 지향 프로그래밍과 비교하여 객체지향프로그래밍이 가장 크게 분별 되는 특징 중 하나.
        5. 다형성(polymorphism)     부모 class에서 물려받은 함수를 자식 class 내에서 필요에 따라 변형할 수 있도록 오버라이딩 하여
                                    사용할 수 있는 것을 말함. 또한 동일한 class를 여러 개로 객체화하면 객체에 따라서 다양하게 다르게
                                    작동할 수 있는 기능이 제공됨. 즉, 상속을 이용하여 기능을 확장하거나 변경하는 것도 다형성의 특징임.

        class: 추상화를 사용자 정의 타입으로 구현하여 이를 객체화하여 사용하는 것.
    
    class 정의 방법: class 키워드와 접근제어(access control) 지시자를 함께 사용함.
        class class이름
        {
        접근제어지시자 1:
            멤버변수1 선언;         //예) int name
            멤버변수2 선언;
            ...
            멤버함수1 선언;         //예) void Func(int a, int b)
            멤버함수2 선언;
            
        접근제어지시자 2:
            멤버변수3 선언;
            멤버변수4 선언;
            ...
            멤버함수3 선언;
            멤버함수4 선언;
            ...
        };
        주의: class 선언은 마지막에 세미콜론(;)으로 마감해주어야 함.
    
    접근제어지시자: class 멤버변수와 함수에 대하여 외부에서 접근을 허용할지 여부를 지정함.
        public :        자신의 class는 물론 외부 class와 전체 함수
        protected :     자신의 class와 상속받아가는 자식 class
        private :       자신의 class 내부에서만 사용 가능(생략 가능)
    
    6_1_classBasic.cpp 참고바람...
    주의:   하나의 class에서 객체를 생성할 때 생성된 인스턴스 객체는 각각 멤버변수들이 메모리 공간에서 독립적인 위치를 차지하지만
            멤버함수는 생성된 모든 객체들이 공유한다는 점은 특이한 사항으로 기억하여야 함.

    멤버함수는 class 외부에 위치시켜도 됨. 일반적으로 멤버함수 내 코딩의 길이가 상대적으로 긴 경우에는 class 내부에는 원형함수로 선언하고
    실행하는 멤버함수의 코드는 외부에 별도로 지정하여 코딩함.
    C++응용프로그램에서는 class 선언은 일반적으로 header파일에 선언, 멤버함수는 cpp파일에서 상세한 코딩이 작성되는 것이 일반적인 구조임.
    외부에서 사용할 경우 ::를 사용하여 멤버함수가 속한 class를 표시해주어야 함.
    형식: 함수자료형 calss이름 :: 함수명(매개변수, , )

    6_2_classBasicOuside.cpp 참고바람... 

    접근제어지시자의 사용범위를 이해하기 위해 몇가지 경우를 고려해 예제 6-3에서 실습해보자

    6_3_classBasicContact.cpp 참고바람...

    -class 설계 팁
        class 이름 앞에는 C를 붙여 가독성을 높임.(생략가능)
        class는 {로 시작해서 };로 끝난다.
        접근제어지시자 허용범위
            -public: 전 영역
            -private: 자신 class 내부
            -protected: 자신 class와 상속받은 자식 class
        접근제어지시자가 생략되면 private로 동작
        멤버함수 실행 코딩 위치는 class 내부와 외부 모두 가능
        멤버함수 실행 코딩 위치 : 외부
            -class 내부에 멤버함수 원형 선언
            -소속 class :: 멤버함수
        실제사용 : 인스턴스된 객체들로 사용
            -class이름 객체명1, 객체명2,...
            -객체명 . 멤버변수
            -객체명 . 멤버함수
        객체 멤버변수는 개체마다 독립적으로 메모리 공간 할당,
        객체 멤버함수는 모든 객체들이 메모리 공간 공유.
        객체 멤버함수, 변수 접근방법
            1.  정적으로 class 객체를 생성한 경우
                객체.멤버함수();
                객체.멤버변수;
            2.  동적으로 class 객체를 생성한 경우
                객체 -> 멤버함수()
                객체 -> .멤버변수
        
[상속]
    상속(Inheritance):  기존에 정의된 class의 모든 멤버변수와 멤버함수를 물려받고 멤버변수와 멤버함수를 추가하여 새로운 class를 설계한다는 의미.
                        기존에 정의되어 있던 class를 부모 또는 기초, 상위 class라고 부름.
                        상속을 받아 새롭게 생성된 class는 자식 또는 파생, 하위 class라고 부름.
                        공통적인 부분은 부모 class에 미리 작성하여야 하고 자식 class에서 중복되는 부분은 생략함.
                        
    장점:               사용자에게 수준높은 코드의 재활용성을 제공함으로써 프로그램이 간결해지고
                        class간에 계층적 관계를 구성함으로써 다형성의 문법적 토대를 제공해줌.
    
    형식:               class 부모class명
                        {
                            // ..
                        };
                        class 자식class명 : 접근제어지시자 부모class명
                        {
                            // ..
                        };
                        접근제어지시자는 일반적으로 public을 사용함. protected를 사용하면 부모의 public으로 된 부분은 모두 protected로 변환되어 상속받음
                        private을 사용하면 전체가 private 형식으로 변환되어 상속받음.

    단일 상속:          자식 calss가 하나의 부모 class로부터 상속받음.
    다중 상속:          여러 개의 부모 class로부터 상속받음.

    -상속 팁
        상속이 가능한 부모 class 멤버변수와 멤버함수 접근제어지시자 : protected
        부모 class의 멤버변수와 멤버함수를 자식 class에서 재선언하지 않아도 사용 가능
        -사용 방법
            자식 class명 : public 부모 class 명
        
        부모 class 멤버변수와 자식 class 멤버변수가 같은 경우 자식 class 멤버변수가 우선으로 적용
        자식 class 객체에서 부모 class 멤버변수를 사용하고자 할 때 : 부모 class명::부모 class의 멤버변수

    6_4_inheritance.cpp 참고바람...
[friend]
    해당 class가 아닌 지정한 calss나 함수에서만 private로 선언된 멤버변수들을 접근할 필요가 있을 수 있음.
    이를 위해 friend라는 새로운 접근제어를 위한 키워드가 제공됨.
    이 키워드로 지정된 해당 class와 함수에서는 private로 선언된 것 여부에 무관하게 public으로 선언한 것처럼 접근 가능.
    friend 키워드는 전역함수, class, 다른 class의 멤버함수 등 세가지 형태로 사용할 수 있음.

    -friend 팁
        friend 선언을 통해 접근이 허용되지 않은 멤버함수, 멤버변수에 대하여 외부의 다른 calss 혹은 함수에서 접근이 가능하도록 허용.
        friend로 허용되는 함수
            ex: friend int main();
        friend로 허용되는 calss
            ex: friend class CMotor;
    
    6_5_friend 참고바람...

[생성자와 소멸자]
    생성자(constructor): 객체가 생성됨과 동시에 최초로 동작하는 함수. 주로 멤버변수들을 초기화 하는데 사용됨.
    객체의 멤버변수 중에는 private으로 선언된 멤버변수는 외부에서 직접 접근할 수 없으므로 객체의 멤버변수는 일반적인 방식으로는 초기화하여 사용 불가능.
    따라서 객체가 생성됨과 동시에 모든 멤버변수에 대하여 초기화할 수 있는 함수가 필요함.
    생성자의 이름은 해당 class의 이름과 동일함. 즉, CMotor라는 class의 생성자는 CMotor()임.

    -생성자 팁
        생성자의 이름은 class 이름과 동일하며, return 값이 없지만, void형으로 선언하지 않음.
        생성자는 초기화를 위한 데이터를 생성자 매개변수의 인수로 전달받을 수 있다.
        생성자는 객체의 생성과 동시에 자동으로 동작한다.
        생성자의 매개변수 형태는 오버로딩 규칙에 따라 여러 개의 생성자를 가질 수 있다.

    소멸자(destructor): 생성한 객체가 소멸시에 자동으로 호출되는 함수.
                        객체의 수명이 끝나면 컴파이럴에 의해 자동으로 호출되며, 사용이 끝난 객체를 정리해줌.
    소멸자의 이름은 해당 class의 이름과 같으며, 이름 앞에 물결 표시(~)를 붙여 생성자와 구분함.
    즉, CMotor class의 소멸자는 ~CMotor()이라는 이름을 가지게 됨.

    -소멸자 팁
        소멸자의 이름은 class 이름과 동일하며, return 값이 없지만, void형으로 선언하지 않음.
        소멸자는 소멸자 함수의 매개변수 인수를 갖지 않음.
        소멸자는 객체가 소멸(파괴)될 때 자동으로 호출되어 동작함.
        소멸자는 생성자와는 달리 단 하나의 소멸자만이 존재함.
        동적으로 생성한 생성자는 delete를 사용하여 메모리에서 해제하여야 소멸자가 자동으로 동작함.
    
    6_6_constDest.cpp 참고바람...
    생성자와 소멸자는 class멤버함수와 같이 class외부에 별도로 위치시켜 코딩할 수 있다.

    생성자와 소멸자를 class 외부에 별도로 위치시켜 실행해보자.
    6_7_inheritConst.cpp 참고바람...

    -상속과 생성자(소멸자) 팁
        부모 class의 생성자와 소멸자는 자식 class에 상속되지 않는다. 별개로 선언하여 사용하여야 한다.
        객체가 생성될 때마다 부모 생성자 -> 자식 생성자 순으로 동작하고
        객체가 사라질 떄는 자식 소멸자 -> 부모 소멸자 순으로 동작한다.
    
    2개의 독립적으로 선언된 class에서 어느 한쪽이 다른쪽의 class를 객체로 생성하여 사용하는 경우 생성자와 소멸자의 관계는 다음과 같다.
        다른 class의 객체 생성자 -> 자신의 객체 생성자 순으로 동작하고
        객체가 사라질 때는 자신의 객체 소멸자 -> 다른 class 객체의 소멸자 순으로 동작함.

    6_8_classInClassInstance.cpp 참고바람...
    
    class에서 생성자와 소멸자는 반드시 필요한 것은 아님. 필요한 경우에만 선언하여 사용하면 됨.
    예제 6_8에 대하여 생성자와 소멸자를 각각 제어하면서 프로그램을 실행해보자.
    C++상위 과정인 MFC의 경우 wizard를 이용하면 생성자와 소멸자는 자동으로 생성되기도 함.
    생성자는 생성자 함수의 매개자료형태에 따라 그 이름을 달리함. 다음 절에서 생성자 형태를 살펴보자.

[오버로딩 생성자, 멤버변수 초기화]
    -오버로딩 생성자
        생성자는 객체의 멤버변수를 초기화할 때 생성자의 매개변수 형태에 따라 생성자를 구분하여 사용가능.
        이러한 생성자의 매개변수 형태는 함수의 오버로딩 규칙(5_6절 참고바람)에 따라 여러 개의 생성자를 가질 수 있음

        -오버로딩 생성자 팁
            기본 생성자(default Constructor) : 매개변수가 없는 기본형
            오버로딩 생성자(Overloading Constructor) : 매개변수의 자료형이 다양한 형태로 선언된 생성자
            소멸자는 매개변수가 없는 기본 소멸자만 있음.

        6_9_overloadingConstDest.cpp 참고바람...
    
    -멤버변수 초기화
        생성자의 가장 큰 용도는 멤버변수 초기화.
        멤버변수를 초기화 하는 방법은 생성자 함수내에 직접 표기하는 방법과 생성자에 직접표기하는 방법이 있음.
        본인이 편리한 방법을 사용하면 됨.

        6_10_constVarInitial.cpp 참고바람...

    [복사생성자 Copy Constructor]
        생성된 객체의 멤버변수 데이터를 같은 class에서 생성된 또 다른 객체의 멤버변수로 일괄복사하는 생성자.

        -복사생성자 팁
            기본 복사생성자 : C++ 기본 기능을 사용하여 객체간에 멤버변수끼리 초기값을 자동으로 복사해줌
                class명 객체1;
                class명 객체2=객체1; 또는 class명 객체2(객체1);
            
            기본 복사생성자로 객체의 멤버변수끼리 복사하는 경우, 멤버변수가 동적으로 선언되어 있으면 주소복사로 인하여 객체의 멤버변수간에
            메모리 공유로 버그가 발생함.

            명시적 복사생성자
                class명(const class명& 객체명)
                {
                    매개변수=객체명.매개변수;
                }
            
            동적으로 객체를 생성하여 객체 복사를 하는 경우 기본 복사생성 혹은 명시적 복사생성자를 사용하면 메모리 공유로 버그가 발생함.
            동적으로 객체를 생성한 경우에는 명시적 복사생성자를 이용하여야 하며, 이때 메모리 공유로 복사생성자를 사용할 수 없고 각각
            생성된 객체의 멤버변수들을 초기화 하여야 함.

        -기본 복사생성자(default copy constructor)
            대입연산자 =을 이용하여 기존 객체에서 새로운 객체로 멤버변수 데이터를 복사함.
            6_11_defaultCopyCon.cpp 참고바람...
            6_12_defaultCopyCon2.cpp 참고바람... <-동적으로 객체를 생성하는 경우
            
            동적으로 객체를 생성하여 메모리를 할당하고 대입 연산자를 이용해 복사하면 데이터가 아닌 주소가 객체에 복사됨.
            따라서 메모리를 공유하게 되어 하나의 객체의 멤버변수 값들이 변경되면 동시에 모든 객체의 멤버변수의 데이터가 변경이 일어남.
        
        -명시적 복사생성자(copy constructor)
            6_13_copyCon.cpp 참고바람...
            명시적 복사생성자를 선언하여 사용시 메모리 문제에서 발생하는 버그 해결가능.
            단, 6_12와 같이 동적으로 객체를 생성하면 명시적으로 복사생성자를 선언하여 사용해도 동저긍로 객체를 생성할 때 주소를
            복사하는 방식이므로 하나의 객체에서 데이터가 수정되면 다른 객체의 멤버변수의 데이터가 동시에 변경됨.

            6_14_copyCon2.cpp 참고바람...
            동적으로 각각 생성한 객체에 대하여 명시적 복사생성자를 사용하고자 하더라도 주소를 복사하는 형태이므로 객체들은 같은 메모리 주소를 공유하게됨.
            따라서 객체가 동적으로 생성되는 경우에는 각각 생성된 객체마다 독립적으로 데이터를 초기화하여야함.
        
        멤버변수가 모두 동적으로 할당되지 않음 -> 기본 복사생성자 사용
        멤버변수중 동적으로 할당된 것이 있음   -> 명시적 복사생성자 사용
        객체가 동적으로 생성됨                -> 일일이 초기화

        -상속과 복사생성자
            -상속과 복사생성자 팁
                -부모 class의 기본 생성자는 무조건 선언되어 있어야 한다.
                선언되어 있지 않으면 compile 할 때 error가 발생한다.
                -자식 class의 객체생성, 멤버변수 초기화하면
                부모 clas의 기본생성자 동작 -> 자식 class의 오버로딩 생성자 동작.
                -1. 자식class의 객체 신규 생성 = 기 생성된 자식class의 객체의 초기값 복사
                2. 부모class의 객체 신규 생성 = 기 생성된 자식class의 객체의 초기값 복사
                3. 부모class의 객체 신규 생성 = 기 생성된 부모class의 객체의 초기값 복사
                객체끼리 멤버변수 값 자동으로 복사하는 기본 복사생성자 동작
                -자식class의 객체 신규 생성 = 기 생성된 부모class의 객체의 초기값 복사 에러(error)
                -부모class 객체생성, 멤버변수 초기화 :
                부모class의 오버로딩 생성자 동작

            6_16_inheritCopyCon.cpp 참고바람...

        
