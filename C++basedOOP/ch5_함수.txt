[함수선언]
    사용자 정의 함수: C언어에서 제공해주는 함수와는 별도로 프로그래머가 정의하여 사용하는 함수.
    용도: 자주 사용하는 프로그램 혹은 반복되는 프로그램을 하나의 함수로 만들어 필요할 때마다 그 함수를 호출하여 사용
    장점: 프로그램을 효율적으로 작성할 수 있음.

    반환자료형 함수명(자료형 매개변수, ...) // 사용자 정의 실행함수(호출되는 함수)
    {
        프로그램
        :
        return 데이터;          //반환자료형이 void인 경우 return문 생략가능
    }
    프로그램 임의함수()
    {
        :
        호출함수명(매개변수, ...); //사용자 정의 호출함수
        :
    }
    호출하는 함수와 호출되는 실행함수명은 반드시 같아야 한다.

    5_1_funcBasic.cpp 참고바람...

[값 호출방식(call by value)]
    함수를 사용하기 위하여 호출하는 호출 함수에서 호출되는 실행함수에 데이터를 복사하여 넘겨줄 수 있음.
    매개변수:   실행함수에서 데이터가 복사되는 변수.
                데이터를 받으면 새로 생성된 매개변수에 데이터가 복사됨. 메모리를 별도로 자교형에 대응하여 생성됨.
    return문:   실행함수에서 처리된 결과나 상태를 호출하는 함수에 보내고자 할 때 사용.
    call by value(값 호출): 함수를 호출할 때 실제 매개변수가 갖고 있는 값을 실행함수의 매개변수에 복사하여 값 자체를 넘겨주는 방식.
                            실행함수 내에서 매개변수 값이 변동되더라도 별도의 메모리 공간에 존재하기 때문에
                            호출하는 함수 입장에선 데이터의 변동이 이루어지지 않음.
    
    5_2_callByValueBasic.cpp 참고바람...
    5_3_callByValuePointer.cpp 참고바람...

    값 호출 방식을 통해 실행함수의 실행 결과를 되돌려 받는 방법은 return을 이용하는 방식으로 1개의 결과를 되돌려 받을 수 있다.

    5_4_CallByValueReturn.cpp 참고바람...

[참조 호출방식(call by reference)]
    참조자&:    메모리 공간을 지칭하는 변수이름에 대하여 동일한 공간에 대하여 다른 이름으로 지칭하는 일종의 별명 또는 별칭.
    주의:       선언과 동시에 무엇을 참조하였는지를 초기화하여야 하며 한 번 초기화되면, 참조하는 대상을 변경할 수 없음.

    5_5_reference 참고바람...

    참조자는 메모리를 효율적으로 사용하기 위하여 제공된 것으로 실행함수에 방대한 양의 데이터를 전달한다고 할 때 사용 될 수 있다.
    이는 함수에서 매개변수를 일반변수로 받게 되면 또 다시 대규모의 메모리를 할당할 수밖에 없는 문제를 초래하기 때문이다.
    5_2를 참조 호출방식으로 바꾸어 보기로 한다.

    5_6_callByReference.cpp 참고바람...

    같은 개념으로 포인터로 선언된 변수에 대해서도 동일하게 적용할 수 있다. 5_3을 참조 호출방식으로 바꾸어 보자.

    5_7_callByReferencePointer.cpp 참고바람...

[포인터 호출방식(call by pointer)]
    배열과 같은 대용량 데이터를 매개변수에 전달할 때는 또다른 매개변수가 독립적으로 선언되어
    데이터가 통째로 메모리 관리 측면에서 복사되므로 비효율적임.
    이런경우에는 참조자를 이용하여 추가 메모리 할당을 하지 않고 직접 데이터에 접근하는 방법과,
    매개변수에 데이터가 아닌 데이터가 저장된 최초의 위치주소를 실행함수의 매개변수에 복사하여 사용하는 방법이 있다.

    포인터 호출방식: 실행함수에 연속적인 데이터의 첫 번째 주소만을 복사해주는 방식.

    5_8_callByPointer.cpp 참고바람...

    포인터로 선언한 주소를 실행함수에 포인터로 복사 전달 하도록 프로그램을 수정하였다.

    5_9_callByPointer2.cpp 참고바람...

    참조자를 이용하거나 포인터를 이용하는 방식 모두 call by reference 방식이라고 부르기도 한다.
    이 방식의 특징은 실행함수에서 매개변수가 여러개라면 변동된 여러개의 매개변수 데이터를 다시 전달 받을 수 있다.

    종합실습: 5_10_callBy.cpp 참고바람...

    -함수호출 팁
        1. 값 호출
            -실행함수의 매개변수에 데이터 복사
            -실행함수의 매개변수는 독립적으로 메모리 할당
            -결과를 되돌려 주려면 return 이용
        
        2. 참조 호출
            -호출함수의 변수와 매칭되는 또 다른 이름(별명)참조자 매개변수 선언
            -같은 메모리의 다른 이름으로 메모리 할당이 없음
            -호출함수 변수와 실행함수 매개변수는 동시에 데이터가 변함.
        
        3. pointer 호출
            -실행함수의 매개변수에 데이터가 저장된 첫 번째 주소 복사
            -실행함수의 매개변수는 주소만 저장하는 메모리를 할당하고 주소 복사
            -같은 주소를 지칭하기 때문에 호출함수 변수와 실행함수 매개변수는 동시에 데이터가 변함.

[함수와 문자열]
    문자열을 정의하는 방법은 배열을 사용하는 것보다 포인터를 사용하는 방법이 훨씬 편리하다
    선언 및 초기화: char *strData= "NICE C++ !!";
    strData는 'N'글자가 저장된 주소 즉 문자열의 첫번째 주소를 의미함. 이는 &strData[0]과 동일함.
    'E'가 저장된 주소는 &strData[3]이다.

    5_11_stringDeliver.cpp 참고바람...
    시작주소를 지정하면 지정된 주소 이후의 모든 문자열이 전달됨.

    string class를 이용해 더 쉽게 문자열을 함수에 전달해보자.
    5_12_stringClassDeliver.cpp 참고바람...

[함수 오버로딩(overloading)]
    함수 오버로딩:   동일한 이름을 갖는 여러 개의 함수가 각각 매개변수들의 자료형 혹은 개수가 다르게 선언되었을 때,
                    호출하는 함수와 실행하는 함수가 서로 매개변수 형식이 일치되는 함수를 자동으로 찾아서 실행하는 것으로
                    함수중복 또는 함수 오버로딩이라고 말한다.

                    5_13_overloading.cpp 참고바람...
    
    함수오버로딩 팁
        -실행 함수명이 같아야 한다.
        -호출함수의 매개변수 개수가 일치하는 실행함수를 먼저 찾는다.
        -개수가 일치하는 실행함수를 찾았으면 이어서 매개변수끼리 자료형이 일치하는 실행함수를 찾아 실행한다.
        -모든 매개변수의 자료형이 일치하여야 한다.

[디폴트 매개변수]
    디폴트 매개변수: 실행함수에서 매개변수의 기본값이 미리 정의된 인수.
                    호출함수에서 실행함수로 데이터를 전달하지 않으면 실행함수는 미리 정의된 매개변수의 디폴트 인수값을 사용하도록 하는 것.
                    호출함수에서 데이터를 지정하면 디폴트 인수 값이 선언되었더라도 전달되는 데이터가 사용됨.
    
    -함수 디폴트 매개변수 팁
        -실행함수에서 매개변수 값이 미리 정해진 매개변수
        -디폴트 인수는 실행함수에서 지정할 수 있다.
        -디폴트 인수는 가장 오른쪽부터 시작하여 좌측으로 순서대로만 지정할 수 있다.
        -여러 개의 인수 중에서 중간 인수만 별도로 디폴트 인수를 지정할 수는 없다.

        (1) void Sum(int x, int y, int z = 4)   //가능
        (2) void Sum(int x, int y=2, int z = 4) //가능
        (3) void Sum(int x, int y, int z)       //에러
        (4) void Sum(int x=1, int y=2, int z)   //오류

        실행함수 void Sum(int x, int y=2, int z = 4) 일 때 호출함수 형태
        Sum(1);         //가능
        Sum(1,2);       //가능
        Sum(1,2,3);     //가능
        Sum(1, ,3);     //에러

        5_14_defaultArgument.cpp 참고바람...

[함수 포인터]
    함수 포인터(function pointer):   실행함수의 시작 주소를 가리키는 포인터 상수.
                                    사용자 정의 실행함수의 이름 자체는 메모리에 저장된 위치의 시작 주소를 가리키는 포인터 상수가 됨.
    
    함수 pointer 팁
        -매개변수의 개수 및 자료형이 동일하지만, 기능을 담당하는 실행함수가 여러 개 존재하는 경우에 적용.
            (예: 4칙 연산 각각 함수)
        -실행함수 매개변수에 함수포인터를 전달하는 경우 사용
        -여러 개의 함수를 배열로 관리하고자 할 때 사용할 수도 있다.
        -주소를 알고 있는 함수의 매개변수에 값들을 보내고 연산결과를 역참조(*)에 의해 데이터를 반환 자료형으로 받는다.

        실행함수선언
        -실행함수1(매개변수1, 매개변수 2...);
        -실행함수2(매개변수1, 매개변수 2...);
        -실행함수n(매개변수1, 매개변수 2...);

        함수포인터 선언
        -반환 자료형( *함수포인터이름)(자료형1, 자료형2, ...);

        사용
        함수포인터이름 = 실행함수명1 .. 실행함수명n중에 사용하고자 하는 함수명;
        함수포인터이름(데이터1, 데이터2 ...);

        5_15_funcPointer.cpp 참고바람 ...

        typedef를 이용하여 함수포인터 이름*fpAddSub를 가독성이 좋도록 표현하기
        5_16_funcPtrTypedef.cpp 참고바람 ...

    callback함수:   매개변수로 함수 객체를 전달해서 호출 함수 내에서 매개변수 함수를 실행하는 것.    
                    파라미터로 일반적인 변수나 값을 전달하는 것이 아닌 함수 자체를 전달함.
        
                    5_17_funcPtrCallback.cpp 참고바람 ...
        
                    typedef를 이용한 간결성과 가독성
                    5_18_funcPtrCallTypedef.cpp 참고바람 ...
    
    함수포인터는 고급 프로그램에서 callback 함수를 구현할 때 사용함.
    일반적인 함수들은 사용자가 필요한 시점에 호출함
    반면에 windows에서 마우스가 눌림, 마우스 드래그, 키보드를 눌림, 비동기 통신신호 감지 등은 정상적인 프로그램과 별도로 늘 감시하고
    있어야 하며, 해당 동작 신호(event)가 들어오면 해당 함수를 호출하여 동작하게 하고 그 결과를 되돌려 받아야 함. 이러한 과정을 수행하도록
    호출하는 함수를 callback 함수라고 함.

    보다 상세한 내용은 '윈도우프로그래밍' 등 상위과정에서 공부하자.

[변수의 사용범위]
    2장에서 공부한 변수들의 사용범위와 속성을 좀 더 깊이 있게 공부해보자.
    
    전역변수의 장점: 모든 함수에서 사용 가능. 함수에서 별도로 선언할 필요 없음.
    전역변수의 단점: 변숫값이 변경되면 전체 함수에 영향을 줌.
                    프로그램이 종료될 때까지 메모리에 값이 상주하고 있어 메모리를 많이 차지해 비효율적임.
                    지역변수와 전역변수 같은 이름으로 사용해 각각 선언한다면 지역변수 값이 우선 사용됨.
    
    지역변수
        함수 내에서 {다음으로 선언된 변수를 지역변수라 함.}를 만나면 메모리에서 해제됨.
        {} 내에 {}가 포함될 수 있음 = 지역변수 내에 또다른 지역변수가 존재할 수 있음.
        같은 이름의 지역변수라면 {}내에 추가된 {}안에 있는 지역변수가 우선적용됨.

        5_19_localVariable.cpp 참고바람...
        메모리 입장에서는 이름이 같을지라도 선언된 위치(어느 {}에서 선언되었는가?)에 따라 메모리에서는 다른 변수명으로 해석되어 저장됨.

    전역변수
        함수 밖에서 선언되어 프로그램이 종료되기 전까지 메모리에 상주하는 변수.
        전역변수는 마이크로프로세서에 interrupt()함수나 C++에서 멀티 함수 기능을 위한 thread 기능에서 주로 사용함.
        또한 C++이상의 객체지향 언어에서 가장 강력한 특징이자 장점 중에 하나인 class에서 선언한 변수는 모두 전역변수임.

        5_20_globalVariable.cpp 참고바람...
        전역 변수명과 지역변수명이 같은 경우에는 지역변수가 우선 적용됨. 단, 변수명 앞에 ::을 붙이면 전역변수가 적용됨.
    
    정적변수(static)
        static 변수이름 = 값;
        특정 구역에서만 사용하는 지역변수이면서 메모리에서는 프로그램이 종료될 때까지 해제되지 않도록 하는 방법.
        정적변수의 유효 범위는 함수 혹은 블록 내에서만 영향을 미치는 지역변수이지만,
        변수의 기억장소는 주 기억 장치인데 프로그램이 실행되어 종료될 떄까지 기억장소에 값이 지워지지 않고 유지됨.
        정적변수의 초기화는 외부 변수와 마찬가지로 컴파일할 때 단 한번만 이루어짐.

        5_21_staticVariable.cpp 참고바람...
        static이 있는 경우에는 }를 만나더라도 메모리에서 해제되지 않으므로 기존 변경된 값을 Test() 내에서만 계속 사용할 수 있다.
        정적변수의 선언과 초기화는 프로그램에서 단 한번만 실행되기 때문에 2번째 이후부터는 명령어를 만나도 실행되지 않음.