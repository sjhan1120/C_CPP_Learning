[구조체 서론]
    구조체:      서로 다른 형태의 변수들을 통합하여 편리하게 처리할 수 있음.
    구조체 선언: 다양한 변수들을 묶어서 하나의 설계도를 구현하는 것.
                이 구조체를 바탕으로 실제로 독립적인 실행 프로그램을 여러 개 작성하면 매우 효율적으로 프로그램이 구현됨.
    멤버변수:    구조체 내 다양한 형태의 변수
    class:      멤버변수에 멤버함수를 포함하여 확장된 구조체.
    
    목표:       객체의 개념을 대략 이해하고 기능을 익힘. 위하여 C언어에서 제공되는 구조체 선언과 활용.

[구조체 선언]
    구조체:         여러가지 자료형으로 선언한 멤버변수를 하나로 묶어 새로운 하나의 자료형으로 만들어 처리하는 자료구조.
    구조체 태그:    위와 같은 자료구조를 대표하는 전체 구조체 이름.
    정의:           "struct 구조체이름"으로 설계도를 작성하고 실제 사용할 "구조체의 객체"들로 메모리에 할당(Instance)하여 사용함.
    *객체(object):   설계도를 근거로 실제 메모리에 상주하면서 동작하는 부분. 값이 들어있는 공간.
    객체 생성:      메모리에 객체가 할당되는 것.

    C++은 객체에 대한 개념을 class에 확대하여 적용한 대표적인 객체지향프로그래밍.

    *객체에 대한 이해를 돕기위한 설명
        커피를 탄다고 가정해보자. 사람이 직접 커피를 탈려면 커피, 설탕, 프림을 직접 조합하여 만든다.
        사람이 직접 커피를 타기 위해선 위와같은 재료를 활용할 줄 알아야하며 재료의 비율에 따라 맛이 달라진다.
        반면 커피 자판기는 정확한 비율을 사용해 커피를 만든다. 자판기가 직접 만들어주기 떄문에 사람은 재료를
        활용하는 방법을 몰라도 된다. 새로운 재료가 추가되면 그저 버튼이 추가될 뿐이다.

        여기서 '사람이 직접 커피를 탄다'는 객체를 사용하지 않았을 때, '자판기가 커피를 탄다'는 객체를 사용
        했을 때를 나타낸다. 커피를 만드는 행위를 하나의 제품으로 만든 자판기가 객체에 해당한다.
        객체를 사용함으로써 객체를 만드는 작업과 객체를 사용하는 작업을 구분하기 때문에 상황변화에 대처하기가 쉽다.
        또한 데이터를 관리하는 행위와 사용하는 행위가 정확하게 구분되어 서로에게 미치는 영향이 적다.
        그리고 데이터에 변화가 생기면 데이터를 관리하는 작업만 수정하면 된다.

        따라서 객체는 자신이 원하는 행위를 역할에 따라서 정확히 구분하고 행위자와 소비자의 연결고리를 단순하게 만들어서
        활용성과 재사용성을 높일 수 있다. C++은 객체지향이며 이 의미는 객체 개념을 사용해서 프로그램을 하겠다는 뜻이다.
        즉, 프로그램에서 필요한 행위들을 일반화 시켜서 객체로 만들고 이 객체를 사용하는 형태로 프로그래밍을 하겠다는 것이다.
    
    -구조체 선언(기본): Type1
        struct 구조체이름(구조체테그)       //설계도
        {
            멤버변수1 선언;
            멤버변수2 선언;
        };

        설계도를 근거로 객체 생성
            -struct 구조체이름 객체1, 객체2,.....;  //메모리에 실제하는 객체 생성(정적)
            -struct 구조체이름 *객체1, *객체2,.....;  //포인터로 객체 생성
            -struct 구조체이름 *객체1 = new struct 구조체이름;  //동적으로 객체생성

        }다음에 반드시 ;를 넣어야 함

        생성된 객체의 멤버변수 사용법
            -정적으로 생성한 경우: 객체명 . 멤버변수
            -포인터, 혹은 동적으로 생성한 경우 : 객체명 -> 멤버변수
            예)
            구조체 A를 B로 객체를 생성할 때
            struct A    B;

            B.멤버변수1
            B.멤버변수2

            구조체 A를 *pB로 객체를 동적으로 생성할 때
                struct A    *pB=new struct 구조체이름;
                pB -> 멤버변수1
                pB -> 멤버변수2
        
        4_1_structBasic.cpp 참고바람...

    -구조체 선언(구조체 변수 포함) : Type2
        struct 구조체 이름      //설계도
        {
            멤버변수1 선언;
            멤버변수2 선언;
        } 객체명1, 객체명2...;  //메모리에 실제하는 객체 행성
                               //모든함수에서 사용될 수 있는 전역변수와 같은 사용범위 개념으로 구조체 객체를 선언함.
    
    -구조체 별칭을 사용하는 방법 : Type3
        typedef struct 구조체이름       //설계도
        {
            구조체 멤버변수1 선언;
            구조체 멤버변수2 선언;
        } 구조체별칭;

        구조체별칭 객체1, 객체2,....;   //메모리에 실제하는 객체 생성
        구조체별칭 *객체1, *객체2,..;   //포인터로 객체 생성
        구조체별칭 *객체=new 구조체별칭


        typedef는 명령어를 다른 이름으로 사용하고자 할 때 사용한다. type def unsigned char BYTE; 라고 미리 별칭을 정의해 놓으면
        변수 선언할 때 BYTE chA;로 축약해서 사용하는 기법이다.
        배포되는 대부분의 프로그램 혹은 library에 적용하는 구조체는 이와 같은 구조체 별칭을 사용하는 형태를 갖는다.

        4_1_structBasic2.cpp 참고바람...

[구조체 초기화]
    일차원 배열을 초기화하는 것과 같음. 각 멤버변수의 초기값은 일차원 배열의 { 와 } 사이에서 이루어지는데 구조체 멤버변수의 순서대로 초기화가 이루어짐.
    만일 구조체의 멤버변수 개수가 5개인데, 3개만 { }사이에 초기화 한다면 구조체 멤버변수 중 마지막 2개는 초기화가 이루어지지 않음.

    4_2_structInitial.cpp 참고바람...

[구조체와 배열]
    4_3_structArr.cpp 참고바람...